# React.Fragement 
 - 요소에 key를 부여하지 않아도 에러가 나지 않는다
 - 요소의 순서가 일종의 key 역할을 해주기 떄문-
 - 기존의 jsx 문법에서는 렌더링 시 태그로 감싸줘야 하는데 fragment를 사용 시 불필요한 태그 렌더링을 하지 않아도 된다.
 ``` 
    <React.Fragement> // === <>와 동일
       rendering 하는 내용
    </React.Fragement> </>
```

 - 컴포넌트의 key를 변경하게 되면 컴포넌트가 삭제된다 <br/>
 - 조건부 렌더링으로 컴포넌트의 mount,unmount를 설정할 수 있다.
 - 컴포넌트 생성 mount, 삭제 unmount

<br/>

 # 가상 돔
  - 렌더 단계 (가상돔) => 커밋 단계 (실제 돔)
  - 가상돔에서 이전 가상돔과 비교하여 변경사항만 파악하여 실제 돔에 반영

  <br/>

  # React Hook
   - 컴포넌트에 기능을 추가할때 사용하는 함수
   - 클래스형 컴포넌트 보다 장점이 많다. 하지만 레거시는 클래스형도 많음으로 라이프사이클 정도는 파악하는것이 좋다.

   <br/>

  ## useState
   - 상태값 추가
   - 상태값 변경 처리는 비동기이면서 배치로 처리된다. 
   ```
   const [변수명,변수변경함수] = useState(초기값) EX) const [count,setCount] = useState(0);

   function onClick(){
      setCount(count + 1 ) // 비동기 처리
      setCount(v => v + 1) // 이전의 값을 받아서 변수 변경 
   }

   ```

  ## useEffect
   -  부수효과 처리
   -  서버 API 호출, 이벤트 핸들러 등록 등
   ```
   useEffect(()=>{
      실행할 함수
      
      return () =>{
         다음 부수효과 함수가 호출되기 직전에 호출할 함수, unmount시 실행할 함수
      }
   },의존성 배열) // 상태값이 변경될 경우 리렌더링이 계속일어나며, 빈배열([])일 경우 화면이 마운트 될때 최초 한번 실행, 특정 변수가 들어가면 해당 변수의 값이 바뀔때 만 실행
   ```